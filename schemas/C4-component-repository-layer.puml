@startuml C4-Component-Repository-Layer
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

LAYOUT_WITH_LEGEND()

title Component Diagram: Repository Layer (Business Logic & Data Access)

Container_Boundary(repo_layer, "Repository Layer") {
    Component(collections_repo, "Collections Repository", "TypeScript Module", "Collection lifecycle management for one-table layout")
    
    Component(points_repo, "Points Repository", "TypeScript Module", "Point CRUD operations and vector search over global table")
    
    Component(utils_tenant, "Tenant Utils", "TypeScript Module", "Tenant/collection name sanitization and key generation")
    
    Component(types_schemas, "Types & Schemas", "TypeScript/Zod", "Shared types and request validation schemas")
    
    ComponentDb(ydb_schema, "Schema Manager", "TypeScript Module", "Ensures qdr__collections metadata table exists")
}

Container(ydb_client, "YDB Client", "ydb-sdk Driver", "Database session management")

Rel(collections_repo, ydb_client, "Uses", "withSession() for YQL queries")
Rel(collections_repo, utils_tenant, "Uses", "tableNameFor(), metaKeyFor()")
Rel(collections_repo, types_schemas, "Uses", "DistanceKind, VectorType")

Rel(points_repo, ydb_client, "Uses", "withSession() for YQL queries")
Rel(points_repo, types_schemas, "Uses", "VectorType, DistanceKind")

Rel(ydb_schema, ydb_client, "Uses", "withSession() to create table")

note right of collections_repo
  **Key Functions:**
  - createCollection(metaKey, dim, distance, vectorType)
  - getCollectionMeta(metaKey) → {table, dimension, distance, vectorType}
  - deleteCollection(metaKey)
  - touchCollectionLastAccess(metaKey) — throttled update
  
  **Collection Creation Flow (one-table):**
  1. Ensure qdr__collections metadata table exists
  2. UPSERT metadata row for collection
  
  **Last Access Tracking:**
  - Updated on upsert/search/delete
  - Throttled by LAST_ACCESS_MIN_WRITE_INTERVAL_MS (default 60s)
end note

note left of points_repo
  **Key Functions:**
  - upsertPoints(table, points[], dim, uid) → count
  - searchPoints(table, queryVec, top, withPayload, distance, dim, uid, mode, overfetch) → hits[]
  - deletePoints(table, ids[], uid) → count
  
  **Upsert Flow (one-table):**
  1. Validate vector dimension
  2. Batch UPSERT (UPSERT_BATCH_SIZE, default 100)
  3. Serialize vectors:
     • Server-side: Knn::ToBinaryStringFloat/Bit (default)
     • Client-side: pre-serialized binary (YDB_QDRANT_CLIENT_SIDE_SERIALIZATION_ENABLED)
  
  **Search Strategy (one-table, YDB_QDRANT_SEARCH_MODE):**
  1. exact (default): single-phase KNN over embedding
  2. approximate: bit-quantized candidates (OVERFETCH_MULTIPLIER × top) + exact re-ranking
  
  **Distance Function Mapping:**
  - Cosine → Knn::CosineDistance (converted to similarity in API)
  - Dot → Knn::InnerProductSimilarity
  - Euclid → Knn::EuclideanDistance
  - Manhattan → Knn::ManhattanDistance
end note

note bottom of utils_tenant
  **Sanitization:**
  - Input → [a-z0-9_] only, lowercase
  - Multiple underscores → single
  - Remove leading underscores
  - Default: "default" (tenant), "collection" (name)
  
  **Key Generators:**
  - metaKeyFor(tenant, coll) → "tenant/collection"
  - tableNameFor(tenant, coll) → "qdr_tenant__collection"
end note

note top of ydb_schema
  **ensureMetaTable():**
  - Check if qdr__collections exists via describeTable()
  - If not: create with schema:
    * collection (PK)
    * table_name, vector_dimension
    * distance, vector_type, created_at, last_accessed_at
  - Auto-migrate: add last_accessed_at column if missing
  
  **ensureGlobalPointsTable():**
  - Check if qdrant_all_points exists
  - If not: create with auto-partitioning (100MB)
  - Auto-migrate embedding_quantized if missing (requires YDB_QDRANT_GLOBAL_POINTS_AUTOMIGRATE)
end note

@enduml